initSidebarItems({"constant":[["_SIDD_CMP_EQUAL_ANY",""],["_SIDD_CMP_EQUAL_EACH",""],["_SIDD_CMP_EQUAL_ORDERED",""],["_SIDD_CMP_RANGES",""],["_SIDD_LEAST_SIGNIFICANT",""],["_SIDD_MASKED_NEGATIVE_POLARITY",""],["_SIDD_MOST_SIGNIFICANT",""],["_SIDD_NEGATIVE_POLARITY",""],["_SIDD_POSITIVE_POLARITY",""],["_SIDD_SBYTE_OPS",""],["_SIDD_SWORD_OPS",""],["_SIDD_UBYTE_OPS",""],["_SIDD_UWORD_OPS",""]],"fn":[["_andn_u32","Bitwise logical `AND` of inverted `a` with `b`."],["_andn_u64","Bitwise logical `AND` of inverted `a` with `b`."],["_bextr2_u32","Extracts bits of `a` specified by `control` into the least significant bits of the result."],["_bextr2_u64","Extracts bits of `a` specified by `control` into the least significant bits of the result."],["_bextr_u32","Extracts bits in range [`start`, `start` + `length`) from `a` into the least significant bits of the result."],["_bextr_u64","Extracts bits in range [`start`, `start` + `length`) from `a` into the least significant bits of the result."],["_blcfill_u32","Clears all bits below the least significant zero bit of `x`."],["_blcfill_u64","Clears all bits below the least significant zero bit of `x`."],["_blci_u32","Sets all bits of `x` to 1 except for the least significant zero bit."],["_blci_u64","Sets all bits of `x` to 1 except for the least significant zero bit."],["_blcic_u32","Sets the least significant zero bit of `x` and clears all other bits."],["_blcic_u64","Sets the least significant zero bit of `x` and clears all other bits."],["_blcmsk_u32","Sets the least significant zero bit of `x` and clears all bits above that bit."],["_blcmsk_u64","Sets the least significant zero bit of `x` and clears all bits above that bit."],["_blcs_u32","Sets the least significant zero bit of `x`."],["_blcs_u64","Sets the least significant zero bit of `x`."],["_blsfill_u32","Sets all bits of `x` below the least significant one."],["_blsfill_u64","Sets all bits of `x` below the least significant one."],["_blsi_u32","Extract lowest set isolated bit."],["_blsi_u64","Extract lowest set isolated bit."],["_blsic_u32","Clears least significant bit and sets all other bits."],["_blsic_u64","Clears least significant bit and sets all other bits."],["_blsmsk_u32","Get mask up to lowest set bit."],["_blsmsk_u64","Get mask up to lowest set bit."],["_blsr_u32","Resets the lowest set bit of `x`."],["_blsr_u64","Resets the lowest set bit of `x`."],["_bzhi_u32","Zero higher bits of `a` >= `index`."],["_bzhi_u64","Zero higher bits of `a` >= `index`."],["_lzcnt_u32","Counts the leading most significant zero bits."],["_lzcnt_u64","Counts the leading most significant zero bits."],["_mm256_abs_epi16","Computes the absolute values of packed 16-bit integers in `a`."],["_mm256_abs_epi32","Computes the absolute values of packed 32-bit integers in `a`."],["_mm256_abs_epi8","Computes the absolute values of packed 8-bit integers in `a`."],["_mm256_add_epi16","Add packed 16-bit integers in `a` and `b`."],["_mm256_add_epi32","Add packed 32-bit integers in `a` and `b`."],["_mm256_add_epi64","Add packed 64-bit integers in `a` and `b`."],["_mm256_add_epi8","Add packed 8-bit integers in `a` and `b`."],["_mm256_add_pd","Add packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_add_ps","Add packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_adds_epi16","Add packed 16-bit integers in `a` and `b` using saturation."],["_mm256_adds_epi8","Add packed 8-bit integers in `a` and `b` using saturation."],["_mm256_adds_epu16","Add packed unsigned 16-bit integers in `a` and `b` using saturation."],["_mm256_adds_epu8","Add packed unsigned 8-bit integers in `a` and `b` using saturation."],["_mm256_addsub_pd","Alternatively add and subtract packed double-precision (64-bit) floating-point elements in `a` to/from packed elements in `b`."],["_mm256_addsub_ps","Alternatively add and subtract packed single-precision (32-bit) floating-point elements in `a` to/from packed elements in `b`."],["_mm256_and_si256","Compute the bitwise AND of 256 bits (representing integer data) in `a` and `b`."],["_mm256_andnot_si256","Compute the bitwise NOT of 256 bits (representing integer data) in `a` and then AND with `b`."],["_mm256_avg_epu16","Average packed unsigned 16-bit integers in `a` and `b`."],["_mm256_avg_epu8","Average packed unsigned 8-bit integers in `a` and `b`."],["_mm256_blendv_epi8","Blend packed 8-bit integers from `a` and `b` using `mask`."],["_mm256_ceil_pd","Round packed double-precision (64-bit) floating point elements in `a` toward positive infinity."],["_mm256_ceil_ps","Round packed single-precision (32-bit) floating point elements in `a` toward positive infinity."],["_mm256_cmpeq_epi16","Compare packed 16-bit integers in `a` and `b` for equality."],["_mm256_cmpeq_epi32","Compare packed 32-bit integers in `a` and `b` for equality."],["_mm256_cmpeq_epi64","Compare packed 64-bit integers in `a` and `b` for equality."],["_mm256_cmpeq_epi8","Compare packed 8-bit integers in `a` and `b` for equality."],["_mm256_cmpgt_epi16","Compare packed 16-bit integers in `a` and `b` for greater-than."],["_mm256_cmpgt_epi32","Compare packed 32-bit integers in `a` and `b` for greater-than."],["_mm256_cmpgt_epi64","Compare packed 64-bit integers in `a` and `b` for greater-than."],["_mm256_cmpgt_epi8","Compare packed 8-bit integers in `a` and `b` for greater-than."],["_mm256_floor_pd","Round packed double-precision (64-bit) floating point elements in `a` toward negative infinity."],["_mm256_floor_ps","Round packed single-precision (32-bit) floating point elements in `a` toward negative infinity."],["_mm256_hadd_epi16","Horizontally add adjacent pairs of 16-bit integers in `a` and `b`."],["_mm256_hadd_epi32","Horizontally add adjacent pairs of 32-bit integers in `a` and `b`."],["_mm256_hadds_epi16","Horizontally add adjacent pairs of 16-bit integers in `a` and `b` using saturation."],["_mm256_hsub_epi16","Horizontally substract adjacent pairs of 16-bit integers in `a` and `b`."],["_mm256_hsub_epi32","Horizontally substract adjacent pairs of 32-bit integers in `a` and `b`."],["_mm256_hsubs_epi16","Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b` using saturation."],["_mm256_madd_epi16","Multiply packed signed 16-bit integers in `a` and `b`, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers."],["_mm256_maddubs_epi16","Vertically multiply each unsigned 8-bit integer from `a` with the corresponding signed 8-bit integer from `b`, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers"],["_mm256_max_epi16","Compare packed 16-bit integers in `a` and `b`, and return the packed maximum values."],["_mm256_max_epi32","Compare packed 32-bit integers in `a` and `b`, and return the packed maximum values."],["_mm256_max_epi8","Compare packed 8-bit integers in `a` and `b`, and return the packed maximum values."],["_mm256_max_epu16","Compare packed unsigned 16-bit integers in `a` and `b`, and return the packed maximum values."],["_mm256_max_epu32","Compare packed unsigned 32-bit integers in `a` and `b`, and return the packed maximum values."],["_mm256_max_epu8","Compare packed unsigned 8-bit integers in `a` and `b`, and return the packed maximum values."],["_mm256_max_pd","Compare packed double-precision (64-bit) floating-point elements  in `a` and `b`, and return packed maximum values"],["_mm256_max_ps","Compare packed single-precision (32-bit) floating-point elements in `a` and `b`,  and return packed maximum values"],["_mm256_min_epi16","Compare packed 16-bit integers in `a` and `b`, and return the packed minimum values."],["_mm256_min_epi32","Compare packed 32-bit integers in `a` and `b`, and return the packed minimum values."],["_mm256_min_epi8","Compare packed 8-bit integers in `a` and `b`, and return the packed minimum values."],["_mm256_min_epu16","Compare packed unsigned 16-bit integers in `a` and `b`, and return the packed minimum values."],["_mm256_min_epu32","Compare packed unsigned 32-bit integers in `a` and `b`, and return the packed minimum values."],["_mm256_min_epu8","Compare packed unsigned 8-bit integers in `a` and `b`, and return the packed minimum values."],["_mm256_min_pd","Compare packed double-precision (64-bit) floating-point elements  in `a` and `b`, and return packed minimum values"],["_mm256_min_ps","Compare packed single-precision (32-bit) floating-point elements in `a` and `b`,  and return packed minimum values"],["_mm256_movemask_epi8","Create mask from the most significant bit of each 8-bit element in `a`, return the result."],["_mm256_mul_epi32","Multiply the low 32-bit integers from each packed 64-bit element in `a` and `b`"],["_mm256_mul_epu32","Multiply the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`"],["_mm256_mul_pd","Add packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm256_mul_ps","Add packed single-precision (32-bit) floating-point elements in `a` and `b`."],["_mm256_mulhi_epi16","Multiply the packed 16-bit integers in `a` and `b`, producing intermediate 32-bit integers and returning the high 16 bits of the intermediate integers."],["_mm256_mulhi_epu16","Multiply the packed unsigned 16-bit integers in `a` and `b`, producing intermediate 32-bit integers and returning the high 16 bits of the intermediate integers."],["_mm256_mulhrs_epi16","Multiply packed 16-bit integers in `a` and `b`, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and return bits [16:1]"],["_mm256_mullo_epi16","Multiply the packed 16-bit integers in `a` and `b`, producing intermediate 32-bit integers, and return the low 16 bits of the intermediate integers"],["_mm256_mullo_epi32","Multiply the packed 32-bit integers in `a` and `b`, producing intermediate 64-bit integers, and return the low 16 bits of the intermediate integers"],["_mm256_or_si256","Compute the bitwise OR of 256 bits (representing integer data) in `a` and `b`"],["_mm256_packs_epi16","Convert packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation"],["_mm256_packs_epi32","Convert packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation"],["_mm256_packus_epi16","Convert packed 16-bit integers from `a` and `b` to packed 8-bit integers using unsigned saturation"],["_mm256_packus_epi32","Convert packed 32-bit integers from `a` and `b` to packed 16-bit integers using unsigned saturation"],["_mm256_round_pd","Round packed double-precision (64-bit) floating point elements in `a` according to the flag `b`. The value of `b` may be as follows:"],["_mm256_round_ps","Round packed single-precision (32-bit) floating point elements in `a` according to the flag `b`. The value of `b` may be as follows: 0x00: Round to the nearest whole number. 0x01: Round down, toward negative infinity. 0x02: Round up, toward positive infinity. 0x03: Truncate the values. For a few additional values options, check the LLVM docs: https://github.com/llvm-mirror/clang/blob/dcd8d797b20291f1a6b3e0ddda085aa2bbb382a8/lib/Headers/avxintrin.h#L382"],["_mm256_sad_epu8","Compute the absolute differences of packed unsigned 8-bit integers in `a` and `b`, then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of the 64-bit return value"],["_mm256_sign_epi16","Negate packed 16-bit integers in `a` when the corresponding signed 16-bit integer in `b` is negative, and return the results. Results are zeroed out when the corresponding element in `b` is zero."],["_mm256_sign_epi32","Negate packed 32-bit integers in `a` when the corresponding signed 32-bit integer in `b` is negative, and return the results. Results are zeroed out when the corresponding element in `b` is zero."],["_mm256_sign_epi8","Negate packed 8-bit integers in `a` when the corresponding signed 8-bit integer in `b` is negative, and return the results. Results are zeroed out when the corresponding element in `b` is zero."],["_mm256_sll_epi16","Shift packed 16-bit integers in `a` left by `count` while shifting in zeros, and return the result"],["_mm256_sll_epi32","Shift packed 32-bit integers in `a` left by `count` while shifting in zeros, and return the result"],["_mm256_sll_epi64","Shift packed 64-bit integers in `a` left by `count` while shifting in zeros, and return the result"],["_mm256_slli_epi16","Shift packed 16-bit integers in `a` left by `imm8` while shifting in zeros, return the results;"],["_mm256_slli_epi32","Shift packed 32-bit integers in `a` left by `imm8` while shifting in zeros, return the results;"],["_mm256_slli_epi64","Shift packed 64-bit integers in `a` left by `imm8` while shifting in zeros, return the results;"],["_mm256_sllv_epi32","Shift packed 32-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and return the result."],["_mm256_sllv_epi64","Shift packed 64-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and return the result."],["_mm256_sqrt_pd","Return the square root of packed double-precision (64-bit) floating point elements in `a`."],["_mm256_sqrt_ps","Return the square root of packed single-precision (32-bit) floating point elements in `a`."],["_mm256_sra_epi16","Shift packed 16-bit integers in `a` right by `count` while shifting in sign bits."],["_mm256_sra_epi32","Shift packed 32-bit integers in `a` right by `count` while shifting in sign bits."],["_mm256_srai_epi16","Shift packed 16-bit integers in `a` right by `imm8` while shifting in sign bits."],["_mm256_srai_epi32","Shift packed 32-bit integers in `a` right by `imm8` while shifting in sign bits."],["_mm256_srav_epi32","Shift packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in sign bits."],["_mm256_srl_epi16","Shift packed 16-bit integers in `a` right by `count` while shifting in zeros."],["_mm256_srl_epi32","Shift packed 32-bit integers in `a` right by `count` while shifting in zeros."],["_mm256_srl_epi64","Shift packed 64-bit integers in `a` right by `count` while shifting in zeros."],["_mm256_srli_epi16","Shift packed 16-bit integers in `a` right by `imm8` while shifting in zeros"],["_mm256_srli_epi32","Shift packed 32-bit integers in `a` right by `imm8` while shifting in zeros"],["_mm256_srli_epi64","Shift packed 64-bit integers in `a` right by `imm8` while shifting in zeros"],["_mm256_srlv_epi32","Shift packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,"],["_mm256_srlv_epi64","Shift packed 64-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,"],["_mm256_sub_epi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`"],["_mm256_sub_epi32","Subtract packed 32-bit integers in `b` from packed 16-bit integers in `a`"],["_mm256_sub_epi64","Subtract packed 64-bit integers in `b` from packed 16-bit integers in `a`"],["_mm256_sub_epi8","Subtract packed 8-bit integers in `b` from packed 16-bit integers in `a`"],["_mm256_sub_pd","Subtract packed double-precision (64-bit) floating-point elements in `b` from packed elements in `a`."],["_mm256_sub_ps","Subtract packed single-precision (32-bit) floating-point elements in `b` from packed elements in `a`."],["_mm256_subs_epi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_mm256_subs_epi8","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_mm256_subs_epu16","Subtract packed unsigned 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_mm256_subs_epu8","Subtract packed unsigned 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_mm256_xor_si256","Compute the bitwise XOR of 256 bits (representing integer data) in `a` and `b`"],["_mm_abs_epi16","Compute the absolute value of each of the packed 16-bit signed integers in `a` and return the 16-bit unsigned integer"],["_mm_abs_epi32","Compute the absolute value of each of the packed 32-bit signed integers in `a` and return the 32-bit unsigned integer"],["_mm_abs_epi8","Compute the absolute value of packed 8-bit signed integers in `a` and return the unsigned results."],["_mm_add_epi16","Add packed 16-bit integers in `a` and `b`."],["_mm_add_epi32","Add packed 32-bit integers in `a` and `b`."],["_mm_add_epi64","Add packed 64-bit integers in `a` and \"b`."],["_mm_add_epi8","Add packed 8-bit integers in `a` and `b`."],["_mm_add_pd","Add packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_add_ps","Adds f32x4 vectors."],["_mm_add_sd","Return a new vector with the low element of `a` replaced by the sum of the low elements of `a` and `b`."],["_mm_add_ss","Adds the first component of `a` and `b`, the other components are copied from `a`."],["_mm_adds_epi16","Add packed 16-bit integers in `a` and `b` using saturation."],["_mm_adds_epi8","Add packed 8-bit integers in `a` and `b` using saturation."],["_mm_adds_epu16","Add packed unsigned 16-bit integers in `a` and `b` using saturation."],["_mm_adds_epu8","Add packed unsigned 8-bit integers in `a` and `b` using saturation."],["_mm_and_pd","Compute the bitwise AND of packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_and_si128","Compute the bitwise AND of 128 bits (representing integer data) in `a` and `b`."],["_mm_andnot_pd","Compute the bitwise NOT of `a` and then AND with `b`."],["_mm_andnot_si128","Compute the bitwise NOT of 128 bits (representing integer data) in `a` and then AND with `b`."],["_mm_avg_epu16","Average packed unsigned 16-bit integers in `a` and `b`."],["_mm_avg_epu8","Average packed unsigned 8-bit integers in `a` and `b`."],["_mm_blendv_epi8",""],["_mm_bslli_si128","Shift `a` left by `imm8` bytes while shifting in zeros."],["_mm_bsrli_si128","Shift `a` right by `imm8` bytes while shifting in zeros."],["_mm_clflush","Invalidate and flush the cache line that contains `p` from all levels of the cache hierarchy."],["_mm_cmpeq_epi16","Compare packed 16-bit integers in `a` and `b` for equality."],["_mm_cmpeq_epi32","Compare packed 32-bit integers in `a` and `b` for equality."],["_mm_cmpeq_epi8","Compare packed 8-bit integers in `a` and `b` for equality."],["_mm_cmpeq_pd","Compare corresponding elements in `a` and `b` for equality."],["_mm_cmpeq_sd","Return a new vector with the low element of `a` replaced by the equality comparison of the lower elements of `a` and `b`."],["_mm_cmpestri",""],["_mm_cmpge_pd","Compare corresponding elements in `a` and `b` for greater-than-or-equal."],["_mm_cmpge_sd","Return a new vector with the low element of `a` replaced by the greater-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpgt_epi16","Compare packed 16-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_epi32","Compare packed 32-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_epi8","Compare packed 8-bit integers in `a` and `b` for greater-than."],["_mm_cmpgt_pd","Compare corresponding elements in `a` and `b` for greater-than."],["_mm_cmpgt_sd","Return a new vector with the low element of `a` replaced by the greater-than comparison of the lower elements of `a` and `b`."],["_mm_cmple_pd","Compare corresponding elements in `a` and `b` for less-than-or-equal"],["_mm_cmple_sd","Return a new vector with the low element of `a` replaced by the less-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmplt_epi16","Compare packed 16-bit integers in `a` and `b` for less-than."],["_mm_cmplt_epi32","Compare packed 32-bit integers in `a` and `b` for less-than."],["_mm_cmplt_epi8","Compare packed 8-bit integers in `a` and `b` for less-than."],["_mm_cmplt_pd","Compare corresponding elements in `a` and `b` for less-than."],["_mm_cmplt_sd","Return a new vector with the low element of `a` replaced by the less-than comparison of the lower elements of `a` and `b`."],["_mm_cmpneq_pd","Compare corresponding elements in `a` and `b` for not-equal."],["_mm_cmpneq_sd","Return a new vector with the low element of `a` replaced by the not-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpnge_pd","Compare corresponding elements in `a` and `b` for not-greater-than-or-equal."],["_mm_cmpnge_sd","Return a new vector with the low element of `a` replaced by the not-greater-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpngt_pd","Compare corresponding elements in `a` and `b` for not-greater-than."],["_mm_cmpngt_sd","Return a new vector with the low element of `a` replaced by the not-greater-than comparison of the lower elements of `a` and `b`."],["_mm_cmpnle_pd","Compare corresponding elements in `a` and `b` for not-less-than-or-equal."],["_mm_cmpnle_sd","Return a new vector with the low element of `a` replaced by the not-less-than-or-equal comparison of the lower elements of `a` and `b`."],["_mm_cmpnlt_pd","Compare corresponding elements in `a` and `b` for not-less-than."],["_mm_cmpnlt_sd","Return a new vector with the low element of `a` replaced by the not-less-than comparison of the lower elements of `a` and `b`."],["_mm_cmpord_pd","Compare corresponding elements in `a` and `b` to see if neither is `NaN`."],["_mm_cmpord_sd","Return a new vector with the low element of `a` replaced by the result of comparing both of the lower elements of `a` and `b` to `NaN`. If neither are equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise."],["_mm_cmpunord_pd","Compare corresponding elements in `a` and `b` to see if either is `NaN`."],["_mm_cmpunord_sd","Return a new vector with the low element of `a` replaced by the result of comparing both of the lower elements of `a` and `b` to `NaN`. If either is equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise."],["_mm_comieq_sd","Compare the lower element of `a` and `b` for equality."],["_mm_comige_sd","Compare the lower element of `a` and `b` for greater-than-or-equal."],["_mm_comigt_sd","Compare the lower element of `a` and `b` for greater-than."],["_mm_comile_sd","Compare the lower element of `a` and `b` for less-than-or-equal."],["_mm_comilt_sd","Compare the lower element of `a` and `b` for less-than."],["_mm_comineq_sd","Compare the lower element of `a` and `b` for not-equal."],["_mm_cvtepi32_pd","Convert the lower two packed 32-bit integers in `a` to packed double-precision (64-bit) floating-point elements."],["_mm_cvtepi32_ps","Convert packed 32-bit integers in `a` to packed single-precision (32-bit) floating-point elements."],["_mm_cvtpd_epi32","Convert packed double-precision (64-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm_cvtpd_ps","Convert packed double-precision (64-bit) floating-point elements in \"a\" to packed single-precision (32-bit) floating-point elements"],["_mm_cvtps_epi32","Convert packed single-precision (32-bit) floating-point elements in `a` to packed 32-bit integers."],["_mm_cvtsi128_si32","Return the lowest element of `a`."],["_mm_cvtsi128_si64","Return the lowest element of `a`."],["_mm_cvtsi128_si64x","Return the lowest element of `a`."],["_mm_cvtsi32_sd","Return `a` with its lower element replaced by `b` after converting it to an `f64`."],["_mm_cvtsi32_si128","Return a vector whose lowest element is `a` and all higher elements are `0`."],["_mm_cvtsi64_sd","Return `a` with its lower element replaced by `b` after converting it to an `f64`."],["_mm_cvtsi64_si128","Return a vector whose lowest element is `a` and all higher elements are `0`."],["_mm_cvtsi64x_sd","Return `a` with its lower element replaced by `b` after converting it to an `f64`."],["_mm_cvtsi64x_si128","Return a vector whose lowest element is `a` and all higher elements are `0`."],["_mm_div_pd","Divide packed double-precision (64-bit) floating-point elements in `a` by packed elements in `b`."],["_mm_div_ps","Divides f32x4 vectors."],["_mm_div_sd","Return a new vector with the low element of `a` replaced by the result of diving the lower element of `a` by the lower element of `b`."],["_mm_div_ss","Divides the first component of `b` by `a`, the other components are copied from `a`."],["_mm_dp_pd","Returns the dot product of two f64x2 vectors."],["_mm_dp_ps","Returns the dot product of two f32x4 vectors."],["_mm_extract_epi16","Return the `imm8` element of `a`."],["_mm_hadd_epi16","Horizontally add the adjacent pairs of values contained in 2 packed 128-bit vectors of [8 x i16]."],["_mm_hadd_epi32","Horizontally add the adjacent pairs of values contained in 2 packed 128-bit vectors of [4 x i32]."],["_mm_hadds_epi16","Horizontally add the adjacent pairs of values contained in 2 packed 128-bit vectors of [8 x i16]. Positive sums greater than 7FFFh are saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h."],["_mm_hsub_epi16","Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of [8 x i16]."],["_mm_hsub_epi32","Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of [4 x i32]."],["_mm_hsubs_epi16","Horizontally subtract the adjacent pairs of values contained in 2 packed 128-bit vectors of [8 x i16]. Positive differences greater than 7FFFh are saturated to 7FFFh. Negative differences less than 8000h are saturated to 8000h."],["_mm_insert_epi16","Return a new vector where the `imm8` element of `a` is replaced with `i`."],["_mm_lfence","Perform a serializing operation on all load-from-memory instructions that were issued prior to this instruction."],["_mm_load_pd",""],["_mm_load_si128","Load 128-bits of integer data from memory into a new vector."],["_mm_loadl_epi64","Load 64-bit integer from memory into first element of returned vector."],["_mm_loadu_si128","Load 128-bits of integer data from memory into a new vector."],["_mm_madd_epi16","Multiply and then horizontally add signed 16 bit integers in `a` and `b`."],["_mm_maddubs_epi16","Multiply corresponding pairs of packed 8-bit unsigned integer values contained in the first source operand and packed 8-bit signed integer values contained in the second source operand, add pairs of contiguous products with signed saturation, and writes the 16-bit sums to the corresponding bits in the destination."],["_mm_maskmoveu_si128","Conditionally store 8-bit integer elements from `a` into memory using `mask`."],["_mm_max_epi16","Compare packed 16-bit integers in `a` and `b`, and return the packed maximum values."],["_mm_max_epu8","Compare packed unsigned 8-bit integers in `a` and `b`, and return the packed maximum values."],["_mm_max_pd","Return a new vector with the maximum values from corresponding elements in `a` and `b`."],["_mm_max_ps","Compare packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding maximum values."],["_mm_max_sd","Return a new vector with the low element of `a` replaced by the maximum of the lower elements of `a` and `b`."],["_mm_max_ss","Compare the first single-precision (32-bit) floating-point element of `a` and `b`, and return the maximum value in the first element of the return value, the other elements are copied from `a`."],["_mm_mfence","Perform a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior to this instruction."],["_mm_min_epi16","Compare packed 16-bit integers in `a` and `b`, and return the packed minimum values."],["_mm_min_epu8","Compare packed unsigned 8-bit integers in `a` and `b`, and return the packed minimum values."],["_mm_min_pd","Return a new vector with the minimum values from corresponding elements in `a` and `b`."],["_mm_min_ps","Compare packed single-precision (32-bit) floating-point elements in `a` and `b`, and return the corresponding minimum values."],["_mm_min_sd","Return a new vector with the low element of `a` replaced by the minimum of the lower elements of `a` and `b`."],["_mm_min_ss","Compare the first single-precision (32-bit) floating-point element of `a` and `b`, and return the minimum value in the first element of the return value, the other elements are copied from `a`."],["_mm_move_epi64","Return a vector where the low element is extracted from `a` and its upper element is zero."],["_mm_movehl_ps","Combine higher half of `a` and `b`. The highwe half of `b` occupies the lower half of result."],["_mm_movelh_ps","Combine lower half of `a` and `b`. The lower half of `b` occupies the higher half of result."],["_mm_movemask_epi8","Return a mask of the most significant bit of each element in `a`."],["_mm_movemask_pd","Return a mask of the most significant bit of each element in `a`."],["_mm_movemask_ps","Return a mask of the most significant bit of each element in `a`."],["_mm_mul_epu32","Multiply the low unsigned 32-bit integers from each packed 64-bit element in `a` and `b`."],["_mm_mul_pd","Multiply packed double-precision (64-bit) floating-point elements in `a` and `b`."],["_mm_mul_ps","Multiplies f32x4 vectors."],["_mm_mul_sd","Return a new vector with the low element of `a` replaced by multiplying the low elements of `a` and `b`."],["_mm_mul_ss","Multiplies the first component of `a` and `b`, the other components are copied from `a`."],["_mm_mulhi_epi16","Multiply the packed 16-bit integers in `a` and `b`."],["_mm_mulhi_epu16","Multiply the packed unsigned 16-bit integers in `a` and `b`."],["_mm_mulhrs_epi16","Multiply packed 16-bit signed integer values, truncate the 32-bit product to the 18 most significant bits by right-shifting, round the truncated value by adding 1, and write bits [16:1] to the destination."],["_mm_mullo_epi16","Multiply the packed 16-bit integers in `a` and `b`."],["_mm_or_pd","Compute the bitwise OR of `a` and `b`."],["_mm_or_si128","Compute the bitwise OR of 128 bits (representing integer data) in `a` and `b`."],["_mm_packs_epi16","Convert packed 16-bit integers from `a` and `b` to packed 8-bit integers using signed saturation."],["_mm_packs_epi32","Convert packed 32-bit integers from `a` and `b` to packed 16-bit integers using signed saturation."],["_mm_packus_epi16","Convert packed 16-bit integers from `a` and `b` to packed 8-bit integers using unsigned saturation."],["_mm_pause","Provide a hint to the processor that the code sequence is a spin-wait loop."],["_mm_rcp_ps","Return the approximate reciprocal of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_rcp_ss","Return the approximate reciprocal of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged."],["_mm_rsqrt_ps","Return the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_rsqrt_ss","Return the approximate reciprocal square root of the fist single-precision (32-bit) floating-point elements in `a`, the other elements are unchanged."],["_mm_sad_epu8","Sum the absolute differences of packed unsigned 8-bit integers."],["_mm_set1_epi16","Broadcast 16-bit integer `a` to all elements."],["_mm_set1_epi32","Broadcast 32-bit integer `a` to all elements."],["_mm_set1_epi64x","Broadcast 64-bit integer `a` to all elements."],["_mm_set1_epi8","Broadcast 8-bit integer `a` to all elements."],["_mm_set_epi16","Set packed 16-bit integers with the supplied values."],["_mm_set_epi32","Set packed 32-bit integers with the supplied values."],["_mm_set_epi64x","Set packed 64-bit integers with the supplied values, from highest to lowest."],["_mm_set_epi8","Set packed 8-bit integers with the supplied values."],["_mm_setr_epi16","Set packed 16-bit integers with the supplied values in reverse order."],["_mm_setr_epi32","Set packed 32-bit integers with the supplied values in reverse order."],["_mm_setr_epi8","Set packed 8-bit integers with the supplied values in reverse order."],["_mm_setzero_si128","Returns a vector with all elements set to zero."],["_mm_shuffle_epi32","Shuffle 32-bit integers in `a` using the control in `imm8`."],["_mm_shuffle_epi8","Shuffle bytes from `a` according to the content of `b`."],["_mm_shuffle_ps","Shuffle packed single-precision (32-bit) floating-point elements in `a` and `b` using `mask`."],["_mm_shufflehi_epi16","Shuffle 16-bit integers in the high 64 bits of `a` using the control in `imm8`."],["_mm_shufflelo_epi16","Shuffle 16-bit integers in the low 64 bits of `a` using the control in `imm8`."],["_mm_sign_epi16","Negate packed 16-bit integers in `a` when the corresponding signed 16-bit integer in `b` is negative, and return the results. Elements in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sign_epi32","Negate packed 32-bit integers in `a` when the corresponding signed 32-bit integer in `b` is negative, and return the results. Element in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sign_epi8","Negate packed 8-bit integers in `a` when the corresponding signed 8-bit integer in `b` is negative, and return the result. Elements in result are zeroed out when the corresponding element in `b` is zero."],["_mm_sll_epi16","Shift packed 16-bit integers in `a` left by `count` while shifting in zeros."],["_mm_sll_epi32","Shift packed 32-bit integers in `a` left by `count` while shifting in zeros."],["_mm_sll_epi64","Shift packed 64-bit integers in `a` left by `count` while shifting in zeros."],["_mm_slli_epi16","Shift packed 16-bit integers in `a` left by `imm8` while shifting in zeros."],["_mm_slli_epi32","Shift packed 32-bit integers in `a` left by `imm8` while shifting in zeros."],["_mm_slli_epi64","Shift packed 64-bit integers in `a` left by `imm8` while shifting in zeros."],["_mm_slli_si128","Shift `a` left by `imm8` bytes while shifting in zeros."],["_mm_sllv_epi32","Shift packed 32-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and return the result."],["_mm_sllv_epi64","Shift packed 64-bit integers in `a` left by the amount specified by the corresponding element in `count` while shifting in zeros, and return the result."],["_mm_sqrt_pd","Return a new vector with the square root of each of the values in `a`."],["_mm_sqrt_ps","Return the square root of packed single-precision (32-bit) floating-point elements in `a`."],["_mm_sqrt_sd","Return a new vector with the low element of `a` replaced by the square root of the lower element `b`."],["_mm_sqrt_ss","Return the square root of the first single-precision (32-bit) floating-point element in `a`, the other elements are unchanged."],["_mm_sra_epi16","Shift packed 16-bit integers in `a` right by `count` while shifting in sign bits."],["_mm_sra_epi32","Shift packed 32-bit integers in `a` right by `count` while shifting in sign bits."],["_mm_srai_epi16","Shift packed 16-bit integers in `a` right by `imm8` while shifting in sign bits."],["_mm_srai_epi32","Shift packed 32-bit integers in `a` right by `imm8` while shifting in sign bits."],["_mm_srav_epi32","Shift packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in sign bits."],["_mm_srl_epi16","Shift packed 16-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srl_epi32","Shift packed 32-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srl_epi64","Shift packed 64-bit integers in `a` right by `count` while shifting in zeros."],["_mm_srli_epi16","Shift packed 16-bit integers in `a` right by `imm8` while shifting in zeros."],["_mm_srli_epi32","Shift packed 32-bit integers in `a` right by `imm8` while shifting in zeros."],["_mm_srli_epi64","Shift packed 64-bit integers in `a` right by `imm8` while shifting in zeros."],["_mm_srli_si128","Shift `a` right by `imm8` bytes while shifting in zeros."],["_mm_srlv_epi32","Shift packed 32-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,"],["_mm_srlv_epi64","Shift packed 64-bit integers in `a` right by the amount specified by the corresponding element in `count` while shifting in zeros,"],["_mm_store_pd",""],["_mm_store_si128","Store 128-bits of integer data from `a` into memory."],["_mm_storel_epi64","Store the lower 64-bit integer `a` to a memory location."],["_mm_storeu_si128","Store 128-bits of integer data from `a` into memory."],["_mm_sub_epi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`."],["_mm_sub_epi32","Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`."],["_mm_sub_epi64","Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`."],["_mm_sub_epi8","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`."],["_mm_sub_pd","Subtract packed double-precision (64-bit) floating-point elements in `b` from `a`."],["_mm_sub_ps","Subtracts f32x4 vectors."],["_mm_sub_sd","Return a new vector with the low element of `a` replaced by subtracting the low element by `b` from the low element of `a`."],["_mm_sub_ss","Subtracts the first component of `b` from `a`, the other components are copied from `a`."],["_mm_subs_epi16","Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a` using saturation."],["_mm_subs_epi8","Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a` using saturation."],["_mm_subs_epu16","Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit integers in `a` using saturation."],["_mm_subs_epu8","Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit integers in `a` using saturation."],["_mm_tzcnt_u32","Counts the number of trailing least significant zero bits."],["_mm_tzcnt_u64","Counts the number of trailing least significant zero bits."],["_mm_ucomieq_sd","Compare the lower element of `a` and `b` for equality."],["_mm_ucomige_sd","Compare the lower element of `a` and `b` for greater-than-or-equal."],["_mm_ucomigt_sd","Compare the lower element of `a` and `b` for greater-than."],["_mm_ucomile_sd","Compare the lower element of `a` and `b` for less-than-or-equal."],["_mm_ucomilt_sd","Compare the lower element of `a` and `b` for less-than."],["_mm_ucomineq_sd","Compare the lower element of `a` and `b` for not-equal."],["_mm_unpackhi_epi16","Unpack and interleave 16-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi32","Unpack and interleave 32-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi64","Unpack and interleave 64-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_epi8","Unpack and interleave 8-bit integers from the high half of `a` and `b`."],["_mm_unpackhi_ps","Unpack and interleave single-precision (32-bit) floating-point elements from the higher half of `a` and `b`."],["_mm_unpacklo_epi16","Unpack and interleave 16-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi32","Unpack and interleave 32-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi64","Unpack and interleave 64-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_epi8","Unpack and interleave 8-bit integers from the low half of `a` and `b`."],["_mm_unpacklo_ps","Unpack and interleave single-precision (32-bit) floating-point elements from the lower half of `a` and `b`."],["_mm_xor_pd","Compute the bitwise OR of `a` and `b`."],["_mm_xor_si128","Compute the bitwise XOR of 128 bits (representing integer data) in `a` and `b`."],["_mulx_u32","Unsigned multiply without affecting flags."],["_mulx_u64","Unsigned multiply without affecting flags."],["_pdep_u32","Scatter contiguous low order bits of `a` to the result at the positions specified by the `mask`."],["_pdep_u64","Scatter contiguous low order bits of `a` to the result at the positions specified by the `mask`."],["_pext_u32","Gathers the bits of `x` specified by the `mask` into the contiguous low order bit positions of the result."],["_pext_u64","Gathers the bits of `x` specified by the `mask` into the contiguous low order bit positions of the result."],["_popcnt32","Counts the bits that are set."],["_popcnt64","Counts the bits that are set."],["_t1mskc_u32","Clears all bits below the least significant zero of `x` and sets all other bits."],["_t1mskc_u64","Clears all bits below the least significant zero of `x` and sets all other bits."],["_tzcnt_u16","Counts the number of trailing least significant zero bits."],["_tzcnt_u32","Counts the number of trailing least significant zero bits."],["_tzcnt_u64","Counts the number of trailing least significant zero bits."],["_tzmsk_u32","Sets all bits below the least significant one of `x` and clears all other bits."],["_tzmsk_u64","Sets all bits below the least significant one of `x` and clears all other bits."]],"type":[["__m128i",""],["__m256i",""]]});